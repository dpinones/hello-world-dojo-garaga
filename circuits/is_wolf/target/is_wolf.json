{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":14447145567440038446,"abi":{"parameters":[{"name":"wolf_index","type":{"kind":"field"},"visibility":"private"},{"name":"wolf_salt","type":{"kind":"field"},"visibility":"private"},{"name":"sheep_alive","type":{"kind":"array","length":16,"type":{"kind":"boolean"}},"visibility":"private"},{"name":"wolf_commitment_input","type":{"kind":"field"},"visibility":"private"},{"name":"sheep_to_check_index","type":{"kind":"field"},"visibility":"public"},{"name":"is_wolf_result","type":{"kind":"field"},"visibility":"public"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"22":{"source":"// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n","path":"std/hash/poseidon/bn254/perm.nr"},"23":{"source":"// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n","path":"std/hash/poseidon/bn254.nr"},"24":{"source":"pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n","path":"std/hash/poseidon/mod.nr"},"61":{"source":"// Circuit for validating when shepherd checks if a sheep is the wolf\n// Verifies:\n// 1. The sheep is alive\n// 2. Whether the sheep is the wolf or not\n// Outputs isWolf as 1 if the sheep is the wolf, 0 otherwise\n\nuse std::hash::poseidon;\n\n// Main function for the shepherd_kill_sheep circuit\nfn main(\n    // Private inputs (only for the wolf)\n    wolf_index: Field,  // Which sheep is the wolf\n    wolf_salt: Field,         // Secret salt for the commitment\n    sheep_alive: [bool; 16],  // Alive status of each sheep\n    wolf_commitment_input: Field, // Commitment hash as private input\n    \n    // Public inputs\n    sheep_to_check_index: pub Field, // Which sheep to check\n    is_wolf_result: pub Field  // Result: 1 if sheep is wolf, 0 if not\n) {\n    // 1. Verify the wolf commitment is valid\n    let computed_commitment = poseidon::bn254::hash_2([wolf_index, wolf_salt]);\n    assert(computed_commitment == wolf_commitment_input);\n    \n    // 2. Verify the sheep to check is alive\n    assert(sheep_alive[sheep_to_check_index as u64]);\n    \n    // 3. Determine if the sheep is the wolf and verify it matches the public input\n    let is_wolf = if wolf_index == sheep_to_check_index { 1 } else { 0 };\n    assert(is_wolf == is_wolf_result);\n}\n","path":"/Users/damianalejandropinones/Documents/temp/noir/hello-world-dojo-garaga/circuits/is_wolf/src/main.nr"}},"names":["main"],"brillig_names":["directive_integer_quotient","directive_invert"]}